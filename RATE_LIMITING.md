# راهکارهای جلوگیری از خطای 429 Rate Limit

این سند راهکارهای پیاده‌سازی شده برای جلوگیری از خطای 429 (Rate Limit) را توضیح می‌دهد.

## راهکارهای پیاده‌سازی شده

### 1. Rate Limiter با Token Bucket Algorithm

یک Rate Limiter با الگوریتم Token Bucket پیاده‌سازی شده که:
- تعداد درخواست‌ها را در هر ثانیه محدود می‌کند (پیش‌فرض: 0.5 درخواست در ثانیه = 1 درخواست هر 2 ثانیه)
- امکان Burst (انفجار درخواست) را با bucket size فراهم می‌کند
- به صورت خودکار delay بین درخواست‌ها را مدیریت می‌کند

### 2. Request Queue

یک صف درخواست که:
- تمام درخواست‌های HTTP را در صف قرار می‌دهد
- درخواست‌ها را به صورت sequential (پشت سر هم) پردازش می‌کند
- با Rate Limiter یکپارچه شده است
- در صورت دریافت 429، درخواست را دوباره به صف اضافه می‌کند

### 3. Adaptive Delays

سیستم delay تطبیقی که:
- در صورت دریافت خطای 429، delay را به صورت تصاعدی افزایش می‌دهد
- در صورت موفقیت، delay را به تدریج کاهش می‌دهد
- از Jitter (تصادفی‌سازی) استفاده می‌کند تا درخواست‌ها همزمان نشوند

### 4. Circuit Breaker

یک Circuit Breaker که:
- در صورت دریافت 3 خطای 429 متوالی، circuit را باز می‌کند
- برای 1 دقیقه تمام درخواست‌ها را متوقف می‌کند
- پس از timeout، به صورت خودکار circuit را می‌بندد و دوباره تلاش می‌کند

### 5. Retry Logic با Exponential Backoff

سیستم retry که:
- در صورت خطای 429، با exponential backoff دوباره تلاش می‌کند
- از header `Retry-After` سرور استفاده می‌کند (در صورت وجود)
- حداکثر 3 بار retry می‌کند

## تنظیمات

تنظیمات rate limiting در فایل `src/config/config.js` قابل تغییر است:

```javascript
RATE_LIMIT: {
  tokensPerSecond: 0.5,      // تعداد درخواست در ثانیه (0.5 = هر 2 ثانیه یک درخواست)
  bucketSize: 2,              // ظرفیت burst
  minDelay: 2000,             // حداقل delay بین درخواست‌ها (میلی‌ثانیه)
  maxDelay: 10000,            // حداکثر delay بین درخواست‌ها (میلی‌ثانیه)
  failureThreshold: 3,       // تعداد خطا قبل از باز شدن circuit breaker
  resetTimeout: 60000,        // زمان انتظار قبل از بستن circuit breaker (میلی‌ثانیه)
  maxConcurrent: 1            // حداکثر درخواست‌های همزمان (1 = sequential)
}
```

## نحوه استفاده

تمام درخواست‌های HTTP به صورت خودکار از RequestQueue استفاده می‌کنند. نیازی به تغییر کد موجود نیست.

برای مشاهده آمار rate limiter:

```javascript
const status = await scraperService.getStatus();
console.log(status.rateLimiter);
```

## توصیه‌ها

1. **افزایش delay**: اگر هنوز خطای 429 دریافت می‌کنید، `minDelay` را افزایش دهید (مثلاً 3000 یا 4000 میلی‌ثانیه)

2. **کاهش tokensPerSecond**: اگر مشکل ادامه دارد، `tokensPerSecond` را کاهش دهید (مثلاً 0.33 = هر 3 ثانیه یک درخواست)

3. **افزایش resetTimeout**: اگر circuit breaker زیاد باز می‌شود، `resetTimeout` را افزایش دهید

4. **نظارت بر آمار**: به صورت منظم آمار rate limiter را بررسی کنید تا ببینید آیا نیاز به تنظیمات بیشتر دارید

## مثال تنظیمات محافظه‌کارانه

برای اطمینان بیشتر از عدم دریافت خطای 429:

```javascript
RATE_LIMIT: {
  tokensPerSecond: 0.33,     // هر 3 ثانیه یک درخواست
  bucketSize: 1,              // بدون burst
  minDelay: 3000,             // حداقل 3 ثانیه delay
  maxDelay: 15000,            // حداکثر 15 ثانیه delay
  failureThreshold: 2,        // بعد از 2 خطا circuit باز شود
  resetTimeout: 120000,      // 2 دقیقه انتظار
  maxConcurrent: 1
}
```

## نکات مهم

- **بدون پراکسی**: تمام این راهکارها بدون نیاز به پراکسی کار می‌کنند
- **خودکار**: تمام مدیریت rate limiting به صورت خودکار انجام می‌شود
- **قابل تنظیم**: تمام پارامترها قابل تنظیم هستند
- **مانیتورینگ**: آمار کامل rate limiting در دسترس است

